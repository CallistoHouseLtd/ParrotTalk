/*******************************************************************************
 * The MIT License (MIT)
 *
 * Copyright (c) 2003, 2016 Robert Withers
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * ******************************************************************************
 * murmur/whisper would not be possible without the ideas, implementation, 
 * brilliance and passion of the Squeak/Pharo communities and the cryptography 
 * team, which are this software's foundation.
 *******************************************************************************/

package club.callistohouse.session.marshmuck;

import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Random;

public class DiffieHellman {

	BigInteger prime;
	BigInteger generator;
	BigInteger secret;
	BigInteger sharedKey;

	public DiffieHellman(BigInteger prime, BigInteger generator) {
		this.prime = prime;
		this.generator = generator;
	}
	public byte[] getSharedKey() { return convertToUnpadded(sharedKey); }
	public byte[] sendMessage() throws NoSuchAlgorithmException {
		generateSecretIfNull();
		BigInteger a = generator.modPow(secret, prime);
		return a.toByteArray();
	}
	public byte[] receiveMessage(byte[] message) throws NoSuchAlgorithmException {
		BigInteger b = new BigInteger(message);
//		log.debug("DH b message received: " + Hex.encodeHexString(convertToUnpadded(b)));
		generateSecretIfNull();
		sharedKey = b.modPow(secret, prime);
		return getSharedKey();
	}
	public static DiffieHellman defaultDiffieHellman() {
		//String primeString = "119737914775462509838170437650443916377511571523280127227899447719294084320704253537978070284126826302859486033998465467188646855777933154987304015680716743916472238051242730320539605643481248526686248310127334173449056014874439925491652836615915938029029782321539388697349613396698017627677439533107752978203";
		String prime2048String = "74590163000744215664571428206261183464882552592869067139382222056552715349763159120841569799756029042920968184704590129494078052978962320087944021101746026347535981717869532122259590055984951049094749636380324830154777203301864744802934173941573749720376124683717094961945258961821638084501989870923589746845121992752663157772293235786930128078740743810989039879507242078364008020576647135087519356182872146031915081433053440716531771499444683048837650335204793844725968402892045220358076481772902929784589843471786500160230209071224266538164123696273477863853813807997663357544";
		//String prime4096String = "2410530750555128480404832270192663364151467702011751933879637605973789221782066733764999203363704129606725825795791908836919026891008572279149390055807162392250256330675646684985020816653564088393601255551053956979369176574871401825356351905954754425579325059159357541447202402629492024053083609371857904381957718450531530194409655939454417512083190490446411290435095691232982270560658265752336515612669847419162670442726881468759765503413484384231928086567304548873152895471777542041331295452193483437093324721671982381137170877019378736328504429441519086875250180566973371024565100152106601473353543146065929084184839443761934499580540630736001826186860691671091333220442039311122340290032875870162931668119405505272589120967176899988786150725828794681324808761141306035208420342336072781476969098514933550590456108099575280542728823110230945755469657354015996525833497997573904682502893607752601875297516311328768544282391694848545450743456903980185911755737042017862759007701330934172588858437483776006730068785982983620955908093886797832246742091664598696551951967066481707777158422082406362755912735174532008626510101397855286235671736608924747321206806912532048112345468826525444472189337";
		//String prime8192String = "157345719636517349031914787840795183360026638767408444836160735920235148210917033726211387815887627827705734478020107642484343733685369792573630192119966233087501146306930192820578663751275085202735029134165233218735059418478263170152232765849235201818446432337502994935362330762391445622782282188808233481719023314748556540681827122218778443314892898551082111595698662881265243307974381452437785960951265552628296213129452403360830101604097505199781740705432307451931457195515027658141042456770415780753101532761657119773405176782670636159990431046242110269066806953715234509083875822849625443024079782363091299048451894882362926894317144737410441282087015843857000323316529386611928572701191441099308948602118065674778841862859683457510063143565907481167509717395597898116435324594276176450779411007127466632428417211269480952237874103122136155826626065010086324942710578577698756941657706539469172619292724072004893516757846758090804657246366180386616459317441951832470872576691770115451638307909708668436724514737933320911326826644540953907826289361849877948125063114150589391579931187188851025644304200939936966196760357263524952500417867413141502405131682823550195127973649215264576601045541858739802789780576190389687084407336199273626637337897866950261751527618108216040013950635532772881143953429804822509567797838385664767718962777045415062342385185628719101066987179909424268092120496765061015186242220983990959431090680746894303414296373784929929443770350460705235621203392466023610748001779512640457254861862333157206461054655045985638091862666606013674303417122905527926904945274700164246322093583086571900533109509237806760403355758639381362642761236780619035409546864544868783095653083791384327759422256212215723962991728050315089455731844931367915171198000548887703952528172163487350474060019721873857045676627442003382580297401807897989107302369485636815896878674238640030968799093866942336235433036076009161462178114582790758093925108736208927143675696169726584203712093788265443871304067776293587154571463972347302063664207674860814606738004602569743737581476611086029049869127077792650341036396782694638987190703978348703287357298833724438732703598208493492250165432064839743039267287867287073547594633485969051722112239341521098363273151184311767085196493760798520531852225451308154729810823518440374738712737752847138751498891562298998178475412106463438210374879164364055131294017333374624947797050187069";
		BigInteger prime = new BigInteger(prime2048String);
		return new DiffieHellman(prime, BigInteger.valueOf(2));
	}
	private void generateSecretIfNull() throws NoSuchAlgorithmException {
		if(secret == null) {
			SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
			secret = definitePrime(prime.bitLength(), random);
		}
	}
	private static BigInteger definitePrime(int bits, Random rnd) {
	    BigInteger prime = new BigInteger("4");
	    while(!isPrime(prime)) prime = BigInteger.probablePrime(bits,rnd);
	    return prime;
	}
	private static boolean isPrime(BigInteger n) {
		BigInteger lessOne = n.subtract(BigInteger.ONE);
		// get the next prime from one less than number and check with the number
		return lessOne.nextProbablePrime().compareTo(n) == 0;
	}
	private static byte[] convertToUnpadded(BigInteger bigInt) {
		byte[] bytes = bigInt.toByteArray();
		if(bytes[0] != 0) {
			return bytes;
		}
		byte[] newBytes = new byte[bytes.length - 1];
		System.arraycopy(bytes, 1, newBytes, 0, newBytes.length);
		return newBytes;
	}
}
